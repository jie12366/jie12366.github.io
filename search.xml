<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis的pagehelper分页插件详解]]></title>
    <url>%2Fmybati%E7%9A%84pagehelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一、引入分页插件引入分页插件有下面2种方式，推荐使用 Maven 方式。 1、引入jar包：你可以从下面的地址中下载最新版本的 jar 包https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/由于使用了sql 解析工具，你还需要下载 jsqlparser.jar(需要和PageHelper 依赖的版本一致) ：http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/ 2、使用 Maven在 pom.xml 中添加如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 二、 配置拦截器插件特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 1、在 MyBatis 配置 xml 中配置拦截器插件123456789101112131415&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="value1"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2. 在 Spring 配置文件中配置拦截器插件使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置：123456789101112131415&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 以上是官方文档的方法，下面介绍我自己用的一个方法 3、在springboot中用注解的方式配置，个人比较倾向于注解的方式配置123456789101112131415161718192021package com.xiangzhang.config;import com.github.pagehelper.PageHelper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configuration //表示这个类是用作配置的类public class PageHelperConfig &#123; @Bean //表示启用PageHelper这个拦截器 public PageHelper pageHelper()&#123; PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty("offsetAsPageNum","true"); //设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用. p.setProperty("rowBoundsWithCount","true"); //设置为true时，使用RowBounds分页会进行count查询. p.setProperty("reasonable","true"); //启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页。 pageHelper.setProperties(p); return pageHelper; &#125;&#125; 4、分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 5、下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 1)、helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 2）、offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 3）、rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 4）、pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 5）、reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 6）、params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 7）、supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 8）、autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 9）、closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 10）、aggregateFunctions(5.1.5+)：默认为所有常见数据库的聚合函数，允许手动添加聚合函数（影响行数），所有以聚合函数开头的函数，在进行 count 转换时，会套一层。其他函数和列会被替换为 count(0)，其中count列可以自己配置。 重要提示：当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 6、如何选择配置这些参数单独看每个参数的说明可能是一件让人不爽的事情，这里列举一些可能会用到某些参数的情况。 场景一如果你仍然在用类似ibatis式的命名空间调用方式，你也许会用到rowBoundsWithCount， 分页插件对RowBounds支持和 MyBatis 默认的方式是一致，默认情况下不会进行 count 查询，如果你想在分页查询时进行 count 查询， 以及使用更强大的 PageInfo 类，你需要设置该参数为 true。 注： PageRowBounds 想要查询总数也需要配置该属性为 true。 场景二如果你仍然在用类似ibatis式的命名空间调用方式，你觉得 RowBounds 中的两个参数 offset,limit 不如 pageNum,pageSize 容易理解， 你可以使用 offsetAsPageNum 参数，将该参数设置为 true 后，offset会当成 pageNum 使用，limit 和 pageSize 含义相同。 场景三如果觉得某个地方使用分页后，你仍然想通过控制参数查询全部的结果，你可以配置 pageSizeZero 为 true， 配置后，当 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果。 场景四如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0 会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 场景五如果你在 Spring 中配置了动态数据源，并且连接不同类型的数据库，这时你可以配置 autoRuntimeDialect 为 true，这样在使用不同数据源时，会使用匹配的分页进行查询。 这种情况下，你还需要特别注意 closeConn 参数，由于获取数据源类型会获取一个数据库连接，所以需要通过这个参数来控制获取连接后，是否关闭该连接。 默认为 true，有些数据库连接关闭后就没法进行后续的数据库操作。而有些数据库连接不关闭就会很快由于连接数用完而导致数据库无响应。所以在使用该功能时，特别需要注意你使用的数据源是否需要关闭数据库连接。 当不使用动态数据源而只是自动获取 helperDialect 时，数据库连接只会获取一次，所以不需要担心占用的这一个连接是否会导致数据库出错，但是最好也根据数据源的特性选择是否关闭连接。 三、如何在代码中使用重要提示PageHelper.startPage方法重要提示只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。 请不要配置多个分页插件请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring配置方式，请选择其中一种，不要同时配置多个分页插件)！ 分页插件不支持带有for update语句的分页对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。 分页插件不支持嵌套结果映射由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。 分页插件支持以下几种调用方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//第一种，RowBounds方式的调用List&lt;Country&gt; list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(0, 10));//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第四种，参数方法调用//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize( @Param("user") User user, @Param("pageNum") int pageNum, @Param("pageSize") int pageSize);&#125;//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);//第五种，参数对象//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页//有如下 User 对象public class User &#123; //其他fields //下面两个参数名和 params 配置的名字一致 private Integer pageNum; private Integer pageSize;&#125;//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize(User user);&#125;//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 1、下面对最常用的方式进行详细介绍1List&lt;Country&gt; list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的 场景一 和 场景二 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如： 12//这种情况下也会进行物理分页查询List&lt;Country&gt; selectAll(RowBounds rowBounds); 注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的 PageRowBounds，这个对象中增加了 total 属性，执行分页查询后，可以从该属性得到查询总数。 2、PageHelper.startPage 静态方法调用除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 例一： 12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;assertEquals(182, ((Page) list).getTotal()); 例二： 1234567891011121314151617//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null);//list1assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;，//或者使用PageInfo类（下面的例子有介绍）assertEquals(182, ((Page) list).getTotal());//list2assertEquals(1, list2.get(0).getId());assertEquals(182, list2.size()); 例三，使用PageInfo的用法： 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); 3、使用参数方式想要使用参数方式，需要配置 supportMethodsArguments 参数为 true，同时要配置 params 参数。 例如下面的配置： 12345678&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="supportMethodsArguments" value="true"/&gt; &lt;property name="params" value="pageNum=pageNumKey;pageSize=pageSizeKey;"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在 MyBatis 方法中： 1234List&lt;Country&gt; selectByPageNumSize( @Param("user") User user, @Param("pageNumKey") int pageNum, @Param("pageSizeKey") int pageSize); 当调用这个方法时，由于同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。params 提供的几个参数都可以这样使用。 除了上面这种方式外，如果 User 对象中包含这两个参数值，也可以有下面的方法： 1List&lt;Country&gt; selectByPageNumSize(User user); 当从 User 中同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。 注意：pageNum 和 pageSize 两个属性同时存在才会触发分页操作，在这个前提下，其他的分页参数才会生效。 4、PageHelper 安全调用 使用 RowBounds 和 PageRowBounds 参数方式是极其安全的 使用参数方式是极其安全的 使用 ISelect 接口调用是极其安全的ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 select count(*) 的查询方法。 什么时候会导致不安全的分页？PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。 如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 但是如果你写出下面这样的代码，就是不安全的用法： 1234567PageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 1234567List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 如果你对此不放心，你可以手动清理 ThreadLocal 存储的分页参数，可以像下面这样使用： 1234567891011List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); try&#123; list = countryMapper.selectAll(); &#125; finally &#123; PageHelper.clearPage(); &#125;&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这么写很不好看，而且没有必要。欢迎访问我的新博客： http://www/xyj123.xyz]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msyql5.6转mysql8遇到的坑]]></title>
    <url>%2Fmysql5.6%E8%BD%ACmysql8%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[我是用在java Web的项目上面的，所以用的是mysql-connect-java-8.0.11版本的jar包。（8.0.12貌似有点问题？） 连接类的与之前有点不同，不然会报找不到类的错误，如下是正确写法： 1Class.forName("com.mysql.cj.jdbc.Driver"); 然后getconnection的参数也多了一点，首先会报如下错误： 12Caused by: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法是在数据库名后面加上serverTimezone=UTC ，如下:1("jdbc:mysql://127.0.0.1/cart?serverTimezone=UTC&amp;characterEncoding=utf-8", "root", "root"); 然后如果mysql报了如下警告： 1Establishing SSL connection without server's identity verification is not recommended 说明数据库建立了连接，只是不太安全。我们需要在后面加上一小段代码,最后正确连接如下： 1("jdbc:mysql://127.0.0.1/cart?serverTimezone=UTC&amp;characterEncoding=utf-8&amp;useSSL=false", "root", "root")]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo可视化编辑问题的解决]]></title>
    <url>%2Fhexo%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91.html</url>
    <content type="text"><![CDATA[最近一时兴起便用hexo+github搭了一个自己的专属博客，地址： http://www.xyj123.xyz界面确实比CSDN好看太多了，但是编辑文章却比较麻烦，所以hexo的可视化编辑也是一个问题。 试过几个编辑器，最终还是选择了CSDN附带的Markdown编辑器哈哈哈，这样既可以在hexo上发布文章，在CSDN上也可以继续更新文章。 只需要在CSDN上编辑好后，copy到sublime或者nodepad++上，加个front-matter就可以了。毕竟用惯了CSDN的编辑器，还是挺好用的。带的功能也挺多的。 图片上传在这根本不是问题，直接粘贴就可以了，不需要安装任何插件，代码处理的也挺好。（吐槽一下好多Markdown编辑器的图片上传非要上传地址的，搞的有的复制粘贴的图根本没法用，在这里csdn直接帮你解决了哈哈哈）]]></content>
      <categories>
        <category>积累经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过cmd查找端口对应程序解决端口冲突]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在用很多程序，比如nginx，Tomcat，mysql等，经常因为端口被占用而无法运行，所以在这个时候就必须把占用端口的程序给杀死，才能运行当前的程序。（其实好早之前就想记录一下了，只是太懒了）以下所以命令均在cmd命令行进行 1、查看所有进程的端口：1netstat –ano 2、查看某个端口的进程1netstat -ano|findstr [指定端口号] 比如我查找3306端口的进程（也就是mysql），可以看到对应的pid是8512 12netstat -ano|findstr 3306TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 8512 3、杀死某个端口的进程通过以上命令查到对应程序的端口号后，可以打开任务管理器，转到详细信息那一项，匹配与以上pid对应的程序，并右键结束该任务。如图：当然也可以用命令来杀死程序，但我觉得任务管理器更加方便，这里就不赘述相关命令了。]]></content>
      <categories>
        <category>积累经验</category>
      </categories>
      <tags>
        <tag>端口冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建属于自己的博客]]></title>
    <url>%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[一、本地博客搭建1、node.js的下载与安装这里选择windows安装包的方式安装，32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi选择 v8.12.0 版本，然后进行傻瓜式安装，具体步骤这里不赘述。 安装完成后，检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果：12345PATH=C:\oraclexe\app\oracle\product\8.12.0\server\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;C:\Users\rg\AppData\Roaming\npm 我们可以看到环境变量中已经包含了C:\Program Files\nodejs检查node.js版本:输入node –version 显示对应的版本说明安装成功。 2、git的下载和安装在 Windows 上安装 Git 非常简单，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：项目地址：https://gitforwindows.org/ 直接下载安装即可 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。给 Windows 用户的敬告：你应该在 msysGit 提供的 Unix 风格的 shell 来运行 Git。在 Unix 风格的 shell 中，可以使用本书中提及的复杂多行的命令。对于那些需要在 Windows 命令行中使用 Git 的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来（在 Linux 中是单引号）；另外，如果扬抑符（^）作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。因为扬抑符在 Windows 命令行中表示续行（译注：即下一行为这一行命令的继续）。 至此，基本环境和工具已经搭好了，下载开始搭建博客。 3、hexo的安装与配置在命令行（即Git Bash）运行以下命令：npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可：123hexo init hexo(hexo就是你的站点根目录，名字可以自己改)cd hexonpm install hexo的npm的所有相关命令都在这个站点目录下进行，用git bash命令 站点配置文件：站点目录下的_config.yml，路径为hexo_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。路径为hexo\themes\&lt;主题文件夹&gt;_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：hexo server浏览器访问网址： http://localhost:4000/至此，你的本地博客已经搭建完毕。是不是有点小激动，更激动的在后面呢哈哈。 二、部署到github上。首先去www.github.com 注册一个github的账号。然后创建一个仓库，仓库名为: github账号名.github.io 重点来了，将本地博客推到github仓库。 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：npm install hexo-deployer-git --save 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：ssh -T git@github.comyes 3.修改_config.yml（在站点目录下）。文件末尾修改为：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。在冒号后面一定要加空格，不然会报错的。 4.推送到GithubPages。在命令行（即Git Bash）输入以下命令， 返回INFO Deploy done: git即成功推送：hexo d -g 等待1分钟左右，浏览器访问网址： https://Github账号名称.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://Github账号名称.github.io 三、将刚刚的github域名绑定到自己注册的域名。更加个性化。1、域名解析：类型选择为 CNAME；主机记录即域名前缀，填写为www；记录值填写为 Github账号名称.github.io ；解析线路，TTL 默认即可。 2、仓库设置： 打开博客仓库设置：https://github.com/Github账号名称/Github账号名称.github.io/settings 在Custom domain下，填写自定义域名，点击save。 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online）， 保存，并重命名为CNAME（很重要，不能有后缀）。 3、等待10分钟左右。浏览器访问自定义域名。至此，您的Hexo博客已经解析到自定义域名，https://Github账号名称.github.io 依然可用。 好了，到这已经博客已经基本搭建好了，另外主题更换，优化之类的，可自行百度，后期我可能也会继续更新。有兴趣的还可以把博客搭在coding上。速度会更快点。如果喜欢我的博客，可以直接用我的配置好的主题哦，附上项目地址：https://github.com/jie12366/jie12366.github.io]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+mybatis最新版注解配置实现CURD]]></title>
    <url>%2Fspringboot%2Bmybatis%E6%9C%80%E6%96%B0%E7%89%88%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0CURD.html</url>
    <content type="text"><![CDATA[最近开始学后端，然后直接上手了springboot+mybatis。然后就实现了一个小例子，花了我整整一天时间。在这做个小记录，也给在用最新版的同学一个参考。springboot整合mybatis时，我用的是mybatis3.x最新版的注解方式配置的，这样实现的接口看起来更简单点（确实简单点）。建项目啥的我在这就不说了，直接上主要配置吧。 1、applicaltion.properties的配置：1234567spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456mybatis.type-aliases-package=com.xiangzhang.entity (表的实体类所在的包）# 驼峰命名规范 如：数据库字段是 order_id 那么 实体字段就要写成 orderIdmybatis.configuration.map-underscore-to-camel-case=true 2、pom.xml的依赖：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MYSQL包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入第三方数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试包,当我们使用 mvn package 的时候该包并不会被打入,因为它的生命周期只在 test 之内--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、实体类User123456789101112131415package com.xiangzhang.entity;import lombok.Data;import java.io.Serializable;@Datapublic class User implements Serializable &#123; private static final long serialVersionUID = 8655851615465363473L; private int id; private String name; private float hp; private float damage;&#125; 在这里用了Lombok的@Data注解功能，可以省去getter和setter的代码，可以减少不少的代码量，加快开发速度。lombok需要另外引入依赖。lombok需要另外引入依赖。还要加载对应的lombok plugin插件。不然没法使用哦。 4、UserMapper：通过注解方式实现的接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xiangzhang.mapper;import com.xiangzhang.entity.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * 通过注解方式完成接口的实现 */@Mapperpublic interface UserMapper &#123; /**根据英雄id查询英雄属性 * @param 传入的id * @return 查询的结果集 */ @Select("select * from hero where id = #&#123;id&#125;") List&lt;User&gt; returnById(@Param("id") int id); /** * 返回hero表中的所有数据 * @return 所有结果集 */ @Select("select * from hero") List&lt;User&gt; returnResult(); /** * 实现数据插入功能 * @param name 英雄名 * @param hp 英雄血量值 * @param damage 英雄伤害值 * @return 插入是否成功 */ @Insert("insert into hero(name, hp, damage) VALUES(#&#123;name&#125;, #&#123;hp&#125;, #&#123;damage&#125;)") int insert(@Param("name") String name,@Param("hp") float hp,@Param("damage") float damage); /** *根据英雄id更新英雄名 * @param name 英雄名 * @param id 英雄id * @return 更新是否成功 */ @Update("update hero set name = #&#123;name&#125; where id = #&#123;id&#125;") int update(@Param("name") String name,@Param("id") int id); /** * 根据英雄id删除该英雄 * @param id 英雄id * @return 删除是否成功 */ @Delete("delete from hero where id = #&#123;id&#125;") int delete(@Param("id") int id);&#125; 5、最后再来个测试类代码，结果用log方式输出，在控制台可以观察：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xiangzhang;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import com.xiangzhang.entity.User;import com.xiangzhang.mapper.UserMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; private static final Logger log = LoggerFactory.getLogger(DemoApplicationTests.class); @Autowired private UserMapper userMapper; @Test public void test_curd() throws Exception&#123; final int row1 = userMapper.insert("露娜",2500,4500); if(row1 == 1)&#123; log.info("[添加第一个结果] - [&#123;&#125;]","成功"); &#125; final int row2 = userMapper.insert("貂蝉",1200,5600); if(row2 == 1)&#123; log.info("[添加第二个结果] - [&#123;&#125;]","成功"); &#125; final List&lt;User&gt; user = userMapper.returnById(2); log.info("根据用户id查询 - [&#123;&#125;]",user); final int row3 = userMapper.update("狄仁杰",1); if(row3 == 1)&#123; log.info("[更新英雄名] - [&#123;&#125;]","成功"); &#125; final int row4 = userMapper.delete(11); if(row4 == 1)&#123; log.info("[删除英雄] - [&#123;&#125;]","成功"); &#125; final List&lt;User&gt; users = userMapper.returnResult(); log.info("查询hero表的所有数据 - [&#123;&#125;]",users); &#125;&#125; 如果对你有所帮助，记得点个赞哦。]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3+bootstrap3实现响应式布局]]></title>
    <url>%2Fvue-cli3%20%2B%20bootstrap3%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[利用vue-cli3搭建的脚手架，搭配bootstrap3实现移动端和PC端的适配。 1、用px2rem配合lib-flexible让网页适配。lib-flexible作用：让网页根据设备dpr和宽度，利用viewport和html根元素的font-size配合rem来适配不同尺寸的移动端设备安装： 1npm install lib-flexible 引入：入口文件main.js中： 1import "lib-flexible/flexible.js" 2、手写一个js小工具，省略rem的计算，加快开发速度。在src目录下增加一个utils目录，在里面新建一个js文件，写入以下内容： 123456789101112131415// 基准大小const baseSize = 32// 设置 rem 函数function setRem () &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 750 // 设置页面根节点字体大小 document.documentElement.style.fontSize = (baseSize * Math.min(scale, 2)) + 'px'&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function () &#123; setRem()&#125; 在main.js中引入改js文件： 1import "./utils/rem" 然后就可以直接用px写页面啦，而不用去计算rem的值，是不是很舒服呢。 3、使用VW。了解下vw 与 vh单位，以viewport为基准，1vw 与 1vh分别为window.innerWidth 与 window.innerHeight的百分之一安装： 1npm i postcss-px-to-viewport -save -dev 在package.json中配置如下： 12345678910111213141516"postcss": &#123; "plugins": &#123; "autoprefixer": &#123;&#125;, "postcss-pxtorem": &#123; "rootValue": 32, "propList": ["*"] &#125; &#125;, "plugins": &#123; "autoprefixer": &#123;&#125;, "postcss-px-to-viewport": &#123; "viewportWidth": 750, "minPixelValue": 1 &#125; &#125; &#125;, 4、利用bootstrap实现响应式图片在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。对于图片的大小限制一定要在图片的父级元素进行限制。 5、利用bootstrap的栅格系统，下面列一下栅格系统的参数： 超小屏手机 (&lt;768px) 小屏幕平板(&gt;=768px) 中等屏桌面(&gt;=992px) 大屏桌面(&gt;=1200px) 类前缀 .col-xs .col-sm .col-md .col-lg 列数 12 12 12 12 .container最大宽度 None(自动) 750px 970px 1170px 举个移动设备和桌面的例子：123456789101112131415161718&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-12 col-md-8"&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns are always 50% wide, on mobile and desktop --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; 还有更多对响应式的支持，就不一一列举了。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
