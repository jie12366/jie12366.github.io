<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot上传图片到七牛云并存入数据库]]></title>
    <url>%2FToQiniu.html</url>
    <content type="text"><![CDATA[思路是先在表单中提交数据和图片，然后给图片创建一个实际的本地路径，然后用这个路径将图片上传到七牛云储存，上传成功后从七牛云返回文件名，将这个文件名存入数据库中。然后读取图片时只需用http://+域名/+文件名就可以成功取到图片。下面给出代码（从项目中抠出来的，可能不完整，但是思路肯定完整） 引入七牛云的依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;7.2.0&lt;/version&gt; &lt;/dependency&gt; application.properties配置： 这里的ak和sk，在你七牛云账户的密匙管理里面可以看到，bucket是你的对象储存空间名，path是七牛云分配的域名。12345#七牛云配置qiniu.accessKey=01DnQx9eSgMO0vfp00O0tao8A1lynlnT2O8Koodtqiniu.secretKey=hcfyRnCoeZEeNQAJsKSDiDsv2rnR_YOI_-0kkjiBqiniu.bucket=blog_albumqiniu.path=http://poag7m5q9.bkt.clouddn.com 配置类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.lingfei.admin.config;import com.google.gson.Gson;import com.lingfei.admin.utils.QiniuUtil;import com.qiniu.common.Zone;import com.qiniu.storage.BucketManager;import com.qiniu.storage.UploadManager;import com.qiniu.util.Auth;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.web.servlet.MultipartProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.MultipartResolver;import org.springframework.web.multipart.support.StandardServletMultipartResolver;import org.springframework.web.servlet.DispatcherServlet;import javax.servlet.MultipartConfigElement;import javax.servlet.Servlet;/** * @author www.xyjz123.xyz * @date 2019/3/28 15:41 */@Configuration@ConditionalOnClass(&#123;Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class&#125;)@ConditionalOnProperty(prefix = "spring.servlet.multipart", name = "enabled", matchIfMissing = true)@EnableConfigurationProperties(MultipartProperties.class)public class FileUploadConfig &#123; /** * 七牛云配置 */ @Autowired private QiniuUtil qiNiuProperties; private final MultipartProperties multipartProperties; public FileUploadConfig(MultipartProperties multipartProperties) &#123; this.multipartProperties = multipartProperties; &#125; /** * 上传配置 */ @Bean @ConditionalOnMissingBean public MultipartConfigElement multipartConfigElement() &#123; return this.multipartProperties.createMultipartConfig(); &#125; /** * 注册解析器 */ @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) @ConditionalOnMissingBean(MultipartResolver.class) public StandardServletMultipartResolver multipartResolver() &#123; StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver(); multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily()); return multipartResolver; &#125; /** * 华东 Zone.zone0() * 华北 Zone.zone1() * 华南 Zone.zone2() * 北美 Zone.zoneNa0() */ @Bean public com.qiniu.storage.Configuration qiniuConfig() &#123; //华东 return new com.qiniu.storage.Configuration(Zone.zone0()); &#125; /** * 构建一个七牛上传工具实例 */ @Bean public UploadManager uploadManager() &#123; return new UploadManager(qiniuConfig()); &#125; /** * 认证信息实例 * * @return */ @Bean public Auth auth() &#123; return Auth.create(qiNiuProperties.getAccessKey(), qiNiuProperties.getSecretKey()); &#125; /** * 构建七牛空间管理实例 */ @Bean public BucketManager bucketManager() &#123; return new BucketManager(auth(), qiniuConfig()); &#125; /** * 配置gson为json解析工具 * * @return */ @Bean public Gson gson() &#123; return new Gson(); &#125;&#125; 上传service接口类： 12345678910111213141516171819package com.lingfei.admin.service;import com.qiniu.common.QiniuException;import com.qiniu.http.Response;import java.io.File;/** * @author www.xyjz123.xyz * @date 2019/3/28 15:44 */public interface UploadService &#123; /** * 上传文件 * @param file File * @return * @throws QiniuException */ Response uploadFile(File file) throws QiniuException;&#125; 上传service实现类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lingfei.admin.service.impl;import com.lingfei.admin.service.UploadService;import com.lingfei.admin.utils.QiniuUtil;import com.qiniu.common.QiniuException;import com.qiniu.http.Response;import com.qiniu.storage.UploadManager;import com.qiniu.util.Auth;import com.qiniu.util.StringMap;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.io.*;/** * @author www.xyjz123.xyz * @date 2019/3/28 15:46 */@Servicepublic class UploadServiceImpl implements UploadService, InitializingBean &#123; @Autowired private UploadManager uploadManager; @Autowired private Auth auth; @Autowired private QiniuUtil qiNiuProperties; private StringMap putPolicy; String key = null; @Override public Response uploadFile(File file) throws QiniuException &#123; Response response = this.uploadManager.put(file, key, getUploadToken()); int retry = 0; while (response.needRetry() &amp;&amp; retry &lt; 3) &#123; response = this.uploadManager.put(file, key, getUploadToken()); retry++; &#125; return response; &#125; @Override public void afterPropertiesSet() throws Exception &#123; this.putPolicy = new StringMap(); putPolicy.put("returnBody", "&#123;\"key\":\"$(key)\",\"hash\":\"$(etag)\",\"bucket\":\"$(bucket)\",\"width\":$(imageInfo.width), \"height\":$&#123;imageInfo.height&#125;&#125;"); &#125; /** * 获取上传凭证 * * @return */ private String getUploadToken() &#123; return this.auth.uploadToken(qiNiuProperties.getBucket(), null, 3600, putPolicy); &#125;&#125; control类： 123456789101112131415161718192021222324252627282930/** * 接受post方法，将表单传来的数据插入 * @param announce com.lingfei.admin.entity.Announce * @return 服务端跳转到announce.html */ @ApiOperation("插入数据") @PostMapping("/addContent") public String addContent(Announce announce, HttpServletRequest request, @RequestParam("file") MultipartFile file, Model model)&#123; try&#123; //根据时间戳创建文件名 String fileName = System.currentTimeMillis() + file.getOriginalFilename(); //创建文件的实际路径 String destFileName = request.getServletContext().getRealPath("") + "uploaded" + File.separator + fileName; //根据文件路径创建文件对应的实际文件 File destFile = new File(destFileName); //创建文件实际路径 destFile.getParentFile().mkdirs(); //将文件传到对应的文件位置 file.transferTo(destFile); Response response = qiNiuService.uploadFile(destFile); //解析上传成功的结果 DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class); announce.setPicture(putRet.key);//这个就是从七牛云获取的文件名 &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; announceService.save(announce); //存入数据库 return "redirect:announce"; &#125; 我的entity类：（用了大量的注解，这个不解释，有兴趣的可以翻我的博客） 12345678910111213141516171819202122232425262728293031323334353637383940package com.lingfei.admin.entity;import cn.afterturn.easypoi.excel.annotation.Excel;import com.gitee.sunchenbin.mybatis.actable.annotation.Column;import com.gitee.sunchenbin.mybatis.actable.annotation.Table;import com.gitee.sunchenbin.mybatis.actable.command.BaseModel;import com.gitee.sunchenbin.mybatis.actable.constants.MySqlTypeConstant;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.sql.Timestamp;/** * @author 熊义杰 * @date 2019-3-17 */@Data@AllArgsConstructor@NoArgsConstructor@Table(name = "announce")public class Announce extends BaseModel implements Serializable &#123; @Excel(name = "序号", orderNum = "0") @Column(name = "id",type = MySqlTypeConstant.INT, length = 10,isKey = true,isAutoIncrement = true) private int id; @Excel(name = "内容", orderNum = "1") @Column(name = "content",type = MySqlTypeConstant.VARCHAR,length = 400) private String content; @Column(name = "picture",type = MySqlTypeConstant.VARCHAR,length = 30) private String picture; @Excel(name = "时间", exportFormat = "yyyy-MM-dd hh:mm" ,orderNum = "2") @Column(name = "date",type = MySqlTypeConstant.DATETIME) private Timestamp date;&#125; thymeleaf主要文件： 12345678&lt;form action="/admin/addContent" method="post" enctype="multipart/form-data"&gt; &lt;div class="form-group purple-border"&gt; &lt;label for="content"&gt;内容(两百字以内)&lt;/label&gt; &lt;textarea class="form-control" id="content" name="content" rows="3"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" class="btn btn-primary" value="发布"&gt; &lt;/form&gt; 展示文件我只贴上一个显示图片的： 1&lt;td&gt;&lt;img class="img-size" th:src="@&#123;http://poag7m5q9.bkt.clouddn.com/&#123;fileName&#125;(fileName=$&#123;page.picture&#125;)&#125;"&gt;&lt;/td&gt; //page就是这个类的对象名]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>上传图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在云服务器上搭建部署javaEE的环境]]></title>
    <url>%2FjavaEE.html</url>
    <content type="text"><![CDATA[最近在服务器上搭了个部署javaEE的环境，花了我小半天时间，在这记录一下。 一、ftp的安装和配置：1、安装vsftpd1sudo apt-get install vsftpd 2、创建用户，这里介绍一个非常方便的方法：1sudo adduser username（你的用户名） 只要按照步骤一步步走就ok啦。 3、提权 sudo功能的配置文件一般在这里：/etc/sudoers，可以使用gedit 编辑。然而/etc/sudoers的配置文件的注释里说明了，不建议直接修改/etc/sudoers，而是通过在/etc /sudoers.d/文件夹中新增文件来完成配置。 在这个目录下新建一个文件，名字随便，里面加入以下内容1username(你的用户名) ALL=(ALL) ALL 提权： 1chmod 777 -R username（你的用户名） 4、配置打开配置文件： 1vim /etc/vsftpd.conf 修改或增加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 设置为YES时vsftpd以独立运行方式启动，设置为NO时以xinetd方式启动#（xinetd是管理守护进程的，将服务集中管理，可以减少大量服务的资源消耗）listen=YES# 同上，如果支持ipv6网络则有效listen_ipv6=NO# 是否支持匿名用户访问anonymous_enable=NO# 是否支持本地用户访问local_enable=YES# 是否开放本地用户写权限，即是否允许上传write_enable=YES# 本地用户上传文件的权限掩码local_umask=022# 是否允许匿名用户上传文件#anon_upload_enable=YES# 是否允许匿名用户创建目录#anon_mkdir_write_enable=YES# 用户进入目录时是否显示message_file指定的文件内容（需要添加message_file配置项）#dirmessage_enable=YES# 强制ftp数据传输使用20端口，默认YESconnect_from_port_20=YES# 登陆后显示的信息（欢迎信息）ftpd_banner=Horizon FTP.# 为YES时，禁止所有用户访问上级目录，只能访问各自的家目录chroot_local_user=YES# 如果禁止所有用户访问上级目录，即chroot_local_user=YES，则该项需配置为YES# 如果没有配置该项，则要求ftp根目录权限不可写，否则登录时报：500 OOPS错误# vsftp2.3.5之后版本，该配置项需要手动添加allow_writeable_chroot=YES# 和前面同名配置项一样chroot_local_user=YES# 设置chroot_list_file是否有效chroot_list_enable=YES# 当chroot_list_enable=YES时，该文件生效，该文件需要手动添加，存放用户列表# 如果所有用户被限制只能访问家目录，禁止访问上级目录（即chroot_local_user=YES）# 那么该文件内的用户为特权用户，可以不被限制地访问家目录之上的目录# 反之，如果所有用户都不被限制，都可以访问上级目录，即（chroot_local_user=NO）# 则该文件内部的用户为被限制的用户，只能访问各自家目录，禁止访问上级目录chroot_list_file=/etc/vsftpd.chroot_list# 设置vsftpd使用utf8编码的文件系统utf8_filesystem=YES 新建用户列表文件： 1vim /etc/vsftpd.chroot_list 加入你的用户名，退出并保存重启： 1sudo service vsftpd restart 5、传输文件： 可以通过浏览器访问ftp://你的IP地址，获取你的用户目录下的文件进行文件传输 打开我的电脑，输入ftp://你的IP地址，直接进行文件传输。 使用ftp传输工具，这个可以自行下载所有操作都是要输入用户名和密码的。 二、java的安装和配置1、在window下载jdk，通过ftp传到服务器上。2、解压：1tar -zxvf 你下载的tar.gz包 3、环境配置：1sudo vim /etc/profile 最后一行加入以下内容： 1234JAVA_HOME=/usr/local/java/jdk1.8.0_181（你的解压后的jdk）PATH=$PATH:$HOME/bin:$JAVA_HOME/binexport JAVA_HOMEexport PATH 重新加载环境变量的配置文件： 1source /etc/profile 验证jdk是否安装成功： 12345java -versionjava version "1.8.0_201"Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 三、MySQL1、安装：1sudo apt-get install mysql-server mysql-client 期间会提示你输入密码，再重复一次就行 2、验证123sudo netstat -tap | grep mysqltcp 0 0 localhost:mysql *:* LISTEN 20458/mysqld 3、进入1mysql -uroot -p 你的密码 四、tomcat1、在window上下载tomcat的tar.gz包，然后通过ftp传到服务器2、解压，同上。3、进入tomcat的bin目录，修改startup.sh文件：1sudo vi startup.sh 在最后一行前加入以下内容（实际路径以自己的为准）： 12345JAVA_HOME=/usr/lib/jvm/java-8-oracleJRE_HOME=/usr/lib/jvm/java-8-oracle/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATHTOMCAT_HOME=/opt/apache-tomcat-8.0.47 4、启动：1sudo ./startup.sh 如果8080端口被占用，两种方法， 查找占用端口的进程，杀死进程： netstat -anp|grep 8080 这是查看端口 换个端口，打开conf文件夹下面的server.xml文件，找到connect port =“8080”，后面跟着的是http1.1。改为可用端口，保存退出。重启一下。 在浏览器输入http:你的ip地址/你的端口号，就可以看到tomcat啦。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>javaEE部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无需翻墙上Google]]></title>
    <url>%2Fgo%20google.html</url>
    <content type="text"><![CDATA[很多人上Google的方法肯定就是翻墙啦，但是由于vpn不稳定或者嫌翻墙麻烦等原因，使用起来肯定有点不爽吧。我在用的是一个Google访问助手，无需翻墙就可以轻松上Google，使用体验与百度无异（资源当然不一样啦）。下面分享一下这个完美的插件。（好像火狐不能支持这个插件） 下载地址：https://github.com/jie12366/Hello-World/blob/master/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B_v2.3.0%20(1).crx 使用方法，其他浏览器只能打开就行，Google的需要先打开扩展程序里面的开发者模式。然后启动方法里面有介绍，就是把www.hao123.com设置为主页吧，用别人的东西设置个主页问题应该不大啦。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Google助手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录菜鸡第一次用杭电oj]]></title>
    <url>%2Foj%E5%9B%9B%E9%A2%98.html</url>
    <content type="text"><![CDATA[由于为了双创学分，报了学校的一个c语言竞赛实训，虽然大一的时候也学过一点算法（但是后来怕秃头就没学了）。没办法啊，又得重新开始学，然后就做起了老师布置的杭电oj的4道题。分别是1040,1045,1872，2020。这几题的思路其实都很简单，只是我太菜了而已。（代码都是cpp文件） 1、1040这题就是个简单的冒泡排序，只不过是需要一点点加工而已。根据题目描述，我们是需要先输入测试的组数n，然后再输入n行数据，每一行的第一个数是这一行需要排序的数量（大概就这么个意思吧）。 解题思路：先定义一个n来输入测试组数，然后再定义一个一维数组，数组的大小就是n，即每行测试数据的数量。再定义一个二维数组，来存储n行的所有需要排序的数据。然后就直接冒泡排序就行了。有个需要注意的小问题就是，在输出数组的时候，两个数之间要有空格，但是数组末尾不能有空格，不然无法AC的，oj的题好像都是这样。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;/***冒泡对一个数组排序 ，升序*参数：传入的数组，数组的大小n */void Asc(int a[],int n)&#123; int i,j,temp; for(i = 0;i &lt; n;i ++)&#123; for(j = 1;j &lt; n - i;j++)&#123; if(a[j - 1] &gt; a[j])&#123; temp = a[j - 1]; a[j - 1] = a[j]; a[j] = temp; &#125; &#125; &#125;&#125;int main() &#123; int n,i,j; int a[10]; //每组数据大小 int b[10][200]; //存放所有要排序的数据 cin &gt;&gt; n; //输入测试样例组数 /*输入测试数据*/ for(i = 0;i &lt; n;i++)&#123; cin &gt;&gt; a[i]; for(j = 0;j&lt;a[i];j++)&#123; cin &gt;&gt; b[i][j]; &#125; &#125; /*排序，再输出*/ for(i = 0;i&lt;n;i++) &#123; Asc(b[i],a[i]); for(j = 0;j&lt;a[i];j++)&#123; /*对空格进行简单的处理*/ if(j == a[i] - 1)&#123; cout &lt;&lt; b[i][j]; &#125;else&#123; cout &lt;&lt; b[i][j] &lt;&lt; " "; &#125; &#125; cout &lt;&lt; "\n"; &#125; return 0;&#125; 2、1045这题是个简单的DFS应用，碉堡的上下左右四个方向都可以发射炮弹，条件是设置的碉堡不能打到其他的碉堡（可以打到墙）。该题的目的是要输入一个城市地图，然后求得可以设置的最大碉堡数。 解题思路：用dfs进行深度优先遍历，从坐标0,0开始遍历，每一个坐标，都要遍历在其上下左右四个方向的其他坐标的内容，判断是否是一个碉堡，如果是个碉堡，返回false。如果是墙，则忽略。如果既不是墙，又满足以上条件，则把该坐标设置为碉堡，计数变量加一，继续递归调用dfs函数。调用后再回退一步，变量也要改回去。直到所有的点都被访问。（用了一个max函数来求两个函数的最大值，还有一个memset函数用来初始化数组，所以要加入对应的库） 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;memory.h&gt;using namespace std;#define size 4 //大小最大为4 /*以下：W代表墙,D代表碉堡*/char world[size][size]; //城市地图 int n;int Count; //用于计数 int Max = 0; //记录最大值 /*判断当前位置是否可以放置碉堡*/bool judge(int x,int y) &#123; /*往上寻找*/ for(int i = x - 1;i &gt;= 0;i--)&#123; if(world[i][y] == 'D') return false; if(world[i][y] == 'X') break; &#125; /*往左寻找*/ for(int i = y - 1;i &gt;= 0;i--)&#123; if(world[x][i] == 'D') return false; if(world[x][i] == 'X') break; &#125; /*往下寻找*/ for(int i = x + 1;i &lt; 4;i++)&#123; if(world[i][y] == 'D') return false; if(world[i][y] == 'X') break; &#125; /*往右寻找*/ for(int i = y + 1;i &lt; 4;i++)&#123; if(world[x][i] == 'D') return false; if(world[x][i] == 'X') break; &#125; return true;&#125;/*Dfs深度遍历*/void dfs()&#123; Max = max(Count,Max); //记录最大值 /*枚举所有情况，取最大值*/ for(int i = 0;i&lt;n;i++) &#123; for(int j = 0;j&lt;n;j++)&#123; if(world[i][j] == '.' &amp;&amp; judge(i,j))&#123; world[i][j] = 'D'; //符合条件,放入碉堡 Count ++; dfs(); /*回溯后，放回原值*/ world[i][j] = '.'; Count --; &#125; &#125; &#125;&#125; int main()&#123; while(1)&#123; cin &gt;&gt; n; /*如果n为0,则结束循环*/ if(n == 0)&#123; break; &#125; Count = 0; Max = 0; memset(world,0,sizeof(world)); //用memset进行数组的初始化 for(int i = 0;i&lt;n;i++)&#123; getchar(); //读取换行符，因为是char型数组 for(int j = 0;j&lt; n;j++)&#123; cin &gt;&gt; world[i][j]; &#125; &#125; dfs(); cout &lt;&lt; Max &lt;&lt; "\n"; &#125; return 0;&#125; 3、1872这题考的是稳定排序，其实也蛮简单的，但是我因为太不细心了，一直AC不了。（最后还是成功了）具体题意就是，先输入一个数代表有几行数据，然后紧跟着输入这一组数据，每行数据是名字和分数（未排序的）。然后再输入这组数据根据某种算法的排序结果。后面的就不说了。 解题思路：把每行数据用一个结构体表示，结构体内容为名字，分数，还有一个就是该行数据的位置或者序号（应该是一个意思吧）。输入结构体的时候，这个位置的值就等于用于for循环的迭代器的值，具体看代码。然后将这组数据用sort函数排序，排序依据是：降序、数据相等时，位置小的在前。然后就可以判断已经排序好的那组数据，先立两个flag为true。如果在相同的位置，两组数据对应的分数不相同，这明显就是排序错误嘛，立个flag1为false，如果分数相同，位置对应不上，那就是不稳定排序啦。（这个题目描述好像有解释的）。再立flag2为false呗。如果经过上面两个判断，两个flag都还是true的话，那就是正确的稳定排序啦。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define Max 311/*定义一个结构体存储*/ struct node&#123; int score; char name[60]; int pos; //当前元素的位置 &#125;stu[Max];/*返回sort排序的条件*/ bool cmp(node a,node b)&#123; if(a.score != b.score)&#123; return a.score &gt; b.score; &#125; else&#123; return a.pos &lt; b.pos; &#125;&#125;int main() &#123; int N; char reName[311][60]; int reScore[311]; while(scanf("%d",&amp;N) != EOF)&#123; /*待排序数据*/ for(int i = 0;i&lt;N;i++)&#123; cin &gt;&gt; stu[i].name &gt;&gt; stu[i].score; stu[i].pos = i; &#125; /*已排序数据*/ for(int i = 0;i&lt;N;i++) &#123; cin &gt;&gt; reName[i] &gt;&gt; reScore[i]; &#125; /*稳定排序*/ sort(stu,stu+N,cmp); int flag1 = 1; int flag2 = 1; /*判断是错误排序还是不稳定排序*/ for(int i = 0;i&lt;N;i++)&#123; if(stu[i].score != reScore[i]) flag1 = 0; if(strcmp(stu[i].name,reName[i]) != 0) flag2 = 0; &#125; /*输出错误排序结果，已经是否是稳定排序，不稳定排序也输出稳定排序结果*/ if(!flag1)&#123; cout &lt;&lt; "Error" &lt;&lt; "\n"; for(int i = 0;i&lt;N;i++)&#123; cout &lt;&lt; stu[i].name &lt;&lt; " " &lt;&lt; stu[i].score &lt;&lt; "\n"; &#125; &#125; else if(!flag2)&#123; cout &lt;&lt; "Not Stable" &lt;&lt; "\n"; for(int i = 0;i&lt;N;i++)&#123; cout &lt;&lt; stu[i].name &lt;&lt; " " &lt;&lt; stu[i].score &lt;&lt; "\n"; &#125; &#125; else if(flag1 &amp;&amp; flag2)&#123; cout &lt;&lt; "Right" &lt;&lt; "\n"; &#125; &#125; return 0;&#125; 4、2020这题好简单，也没啥好记录的了。就是个加了绝对值运算的冒泡排序。直接上代码吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;using namespace std;#define N 100int a[N];/***冒泡对一个数组排序 ，降序,用绝对值进行比较 */void Desc(int a[],int n)&#123; int i,j,temp; for(i = 0;i &lt; n;i ++)&#123; for(j = 1;j &lt; n - i;j++)&#123; if(abs(a[j - 1]) &lt; abs(a[j]))&#123; temp = a[j - 1]; a[j - 1] = a[j]; a[j] = temp; &#125; &#125; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; while(n != 0)&#123; /*输入数据*/ for(int i = 0;i&lt;n;i++)&#123; cin &gt;&gt; a[i]; &#125; Desc(a,n); //降序绝对值排序 /*输出*/ for(int i = 0;i&lt;n;i++)&#123; if(i == n-1)&#123; cout &lt;&lt; a[i]; &#125; else&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; &#125; cout &lt;&lt; "\n"; cin &gt;&gt; n; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>初解四题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在基于ubuntu16的云服务器搭建gitlab服务。]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAgitlab.html</url>
    <content type="text"><![CDATA[一、安装：1、安装依赖包，输入以下命令：1sudo apt-get install curl openssh-server ca-certificates postfix 执行完后，邮件配置的时候，选择 Internet site，其他的ok就行。 2、用清华大学的镜像安装主程序（国外的太慢了，可能要几个小时）注意: gitlab-ce 镜像仅支持 x86-64 架构（Debian/Ubuntu 用户）1) 首先信任 GitLab 的 GPG 公钥: 1curl https://packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null 2) 进入root管理员用户，输入以下命令： 1vim /etc/apt/sources.list.d/gitlab-ce.list 在打开的文件中加入以下内容： 1deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 3) 安装 gitlab-ce: 12sudo apt-get updatesudo apt-get install gitlab-ce 二、配置和运行1、配置GitLab IP地址，首先运行： 1sudo -e /etc/gitlab/gitlab.rb 在文本中修改”externval_url”之后的域名，指向服务器ip或者ip指向的域名（注意要带有“https://”），这一行在全部文本中位于很靠上面的位置。 2、更新配置并运行： 1sudo gitlab-ctl reconfigure 3.打开 sshd 和 postfix 服务： 12service sshd startservice postfix start 4、为了使 GitLab 社区版的 Web 界面可以通过网络进行访问，我们需要允许 80 端口通过防火墙，这个端口是 GitLab 社区版的默认端口。为此需要运行下面的命令：1sudo iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT 5、检查GitLab是否安装好并且已经正确运行，输入下面的命令： 1sudo gitlab-ctl status 如果显示都在run，则表示正确运行。 到此，你的gitlab服务以及搭建好了，打开浏览器，输入你的服务器ip地址，就可以访问到gitlab的登录界面啦。 然后，会有一个问题，就是gitlab的访问速度会非常慢，简直龟速啊，还容易出现502。。原因是gitlab占用内存太多，导致服务器崩溃。 三、Swap分区Swap分区在系统的物理内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。 云服务器默认swap分区是没启动的，输入free查看,如下显示的都是01234[root@yoyo sbin]# free total used free shared buff/cache availableMem: 3881692 3219200 369316 52184 293176 360244Swap: 0 0 0 创建swap大小为bs*count=4294971392(4G) 1dd if=/dev/zero of=/mnt/swap bs=512 count=8388616 通过mkswap命令将上面新建出的文件做成swap分区 1mkswap /mnt/swap vim编辑/etc/sysctl.conf，加入以下内容： 12vm.swappiness = 60net.ipv4.neigh.default.gc_stale_time=120 启用分区： 12swapon /mnt/swapecho “/data/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab 再次输入free查看： 1234root@instance-v7jtqjmo:~# free total used free shared buff/cache availableMem: 2048060 1693380 68764 29220 285916 154608Swap: 4194304 721644 3472660 可以看到swap分区已经启动了，再次打开你的gitlab页面，发现速度已经是飞快的了，一兆带宽也能飞，速度远超github。]]></content>
      <categories>
        <category>服务搭建</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+mybatis实现自动创建或者更新表]]></title>
    <url>%2Fmybatis%E7%9A%84ACtable%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[今天在一个博客看到的关于引入mybatis的插件actable实现自动创建或者更新表，然后我就照着他的博客做了，但还是踩了很多坑，因为很多东西他都没有说清楚。很无奈，下面贴上我自己的代码。这个插件目前只支持mysql。 首先需要引入三个依赖，第一个依赖是ACtable的依赖，其他两个是支持它的依赖（原博主只丢出了一个依赖，我在这踩了个坑，一直报错bean无法注入）： pom.xml：123456789101112131415161718192021222324&lt;!--增加A.Ctable开源框架，仅限于mysql数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.sunchenbin.mybatis.actable&lt;/groupId&gt; &lt;artifactId&gt;mybatis-enhance-actable&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 在springboot的配置文件中加入ACtable的配置： application.properties:12345678#当mybatis.table.auto=create时，系统启动后，会将所有的表删除掉，然后根据model中配置的结构重新建表，该操作会破坏原有数据。#当mybatis.table.auto=update时，系统会自动判断哪些表是新建的，哪些字段要修改类型等，哪些字段要删除，哪些字段要新增，该操作不会破坏原有数据。#当mybatis.table.auto=none时，系统不做任何处理。mybatis.table.auto=update#mybatis.model.pack这个配置是用来配置要扫描的用于创建表的对象的包名mybatis.model.pack=com.xiangzhang.entity （实体类的包名）#数据库为mysqlmybatis.database.type=mysql 然后就是在目录下创建两个config配置类，我的目录结构如下：我们需要创建的类是，MybatisTableConfig类和MybatisMapperScannerConfig类，具体代码如下（原博主并没有贴出需要导入的类，我又在这踩了个坑） MybatisTableConfig：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.xiangzhang.config;import com.alibaba.druid.pool.DruidDataSource;import org.mybatis.spring.SqlSessionFactoryBean;import org.springframework.beans.factory.annotation.Value;import org.springframework.beans.factory.config.PropertiesFactoryBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;@Configuration@ComponentScan(basePackages = &#123;"com.gitee.sunchenbin.mybatis.actable.manager.*"&#125;)public class MybatisTableConfig &#123; @Value("$&#123;spring.datasource.driverClassName&#125;") private String driver; @Value("$&#123;spring.datasource.url&#125;") private String url; @Value("$&#123;spring.datasource.username&#125;") private String username; @Value("$&#123;spring.datasource.password&#125;") private String password; @Bean public PropertiesFactoryBean configProperties() throws Exception&#123; PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean(); PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); propertiesFactoryBean.setLocations(resolver.getResources("classpath*:application.properties")); return propertiesFactoryBean; &#125; @Bean public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setMaxActive(30); dataSource.setInitialSize(10); dataSource.setValidationQuery("SELECT 1"); dataSource.setTestOnBorrow(true); return dataSource; &#125; @Bean public DataSourceTransactionManager dataSourceTransactionManager() &#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource()); return dataSourceTransactionManager; &#125; @Bean public SqlSessionFactoryBean sqlSessionFactory() throws Exception&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource()); PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); sqlSessionFactoryBean.setMapperLocations(resolver.getResources("classpath*:com/gitee/sunchenbin/mybatis/actable/mapping/*/*.xml")); sqlSessionFactoryBean.setTypeAliasesPackage("com.xiangzhang.entity.*"); return sqlSessionFactoryBean; &#125;&#125; MybatisMapperScannerConfig：1234567891011121314151617181920package com.xiangzhang.config;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@AutoConfigureAfter(MybatisTableConfig.class)public class MyBatisMapperScannerConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer() throws Exception&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setBasePackage("com.xiangzhang.mapper.*;com.gitee.sunchenbin.mybatis.actable.dao.*"); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); return mapperScannerConfigurer; &#125;&#125; com.xiangzhang.entity是实体类的包名， com.xiangzhang.mapper是实现注解方式的SQL接口最后就是实体类啦，我在这里使用了lombok的Data注解，省去了getter和setter: User:1234567891011121314151617181920212223242526package com.xiangzhang.entity;import com.gitee.sunchenbin.mybatis.actable.annotation.Column;import com.gitee.sunchenbin.mybatis.actable.annotation.Table;import com.gitee.sunchenbin.mybatis.actable.command.BaseModel;import com.gitee.sunchenbin.mybatis.actable.constants.MySqlTypeConstant;import lombok.Data;@Data@Table(name = "hero") //表名public class User extends BaseModel &#123; /** * 属性上的注解定义了创建表时的各个字段的属性 */ @Column(name = "id",type = MySqlTypeConstant.INT,length = 11,isKey = true,isAutoIncrement = true) private int id; @Column(name = "name",type = MySqlTypeConstant.VARCHAR,length = 111) private String name; @Column(name = "hp",type = MySqlTypeConstant.DOUBLE,length = 16,decimalLength = 2) private double hp; @Column(name = "damage",type = MySqlTypeConstant.DOUBLE,length = 16,decimalLength = 2) private double damage;&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>ACtable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将自己的本地项目推到github（详细版）]]></title>
    <url>%2F%E9%A1%B9%E7%9B%AE%E6%8E%A8%E5%88%B0github.html</url>
    <content type="text"><![CDATA[本文是写给github的初次接触者，尽量让初学者尽快的学会部署自己的项目。1、注册账号。https://github.com/ 进去后用邮箱注册，一般会选择直接用QQ邮箱2、创建仓库。点击右上角的加号，选择new repositories.填写仓库名，然后点击create repository至此，你已经创建了你的第一个github仓库。 3、下载git客户端，可以参考我的另一篇博客：windows下git的安装 以下所有命令均在git bash上运行4、添加SSH key 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1ssh-keygen -t rsa -C "邮箱地址"（你创建github账号的邮箱） 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12ssh -T git@github.comyes 然后在你项目文件夹的根目录下面运行以下命令： 123git initgit add .(注意这里有个点哦，点的前面还有个空格）git commit -m "你的注释，即你要给这次提交项目的备注" 回到github，进入你之前创建的仓库，把下面指的那个地址copy下来，然后运行以下命令 12git remote add origin git@github.com:jie12366/chat.git（刚刚copy的地址）git push -u origin master(你要提交的分支，这里为master即主分支) 至此，你的本地项目已经成功的部署到了github仓库。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis的pagehelper分页插件详解]]></title>
    <url>%2Fmybati%E7%9A%84pagehelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一、引入分页插件引入分页插件有下面2种方式，推荐使用 Maven 方式。 1、引入jar包：你可以从下面的地址中下载最新版本的 jar 包https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/由于使用了sql 解析工具，你还需要下载 jsqlparser.jar(需要和PageHelper 依赖的版本一致) ：http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/ 2、使用 Maven在 pom.xml 中添加如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 二、 配置拦截器插件特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 1、在 MyBatis 配置 xml 中配置拦截器插件123456789101112131415&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="param1" value="value1"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 2. 在 Spring 配置文件中配置拦截器插件使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置：123456789101112131415&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 以上是官方文档的方法，下面介绍我自己用的一个方法 3、在springboot中用注解的方式配置，个人比较倾向于注解的方式配置123456789101112131415161718192021package com.xiangzhang.config;import com.github.pagehelper.PageHelper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configuration //表示这个类是用作配置的类public class PageHelperConfig &#123; @Bean //表示启用PageHelper这个拦截器 public PageHelper pageHelper()&#123; PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty("offsetAsPageNum","true"); //设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用. p.setProperty("rowBoundsWithCount","true"); //设置为true时，使用RowBounds分页会进行count查询. p.setProperty("reasonable","true"); //启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页。 pageHelper.setProperties(p); return pageHelper; &#125;&#125; 4、分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 5、下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 1)、helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 2）、offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 3）、rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 4）、pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 5）、reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 6）、params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 7）、supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 8）、autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 9）、closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 10）、aggregateFunctions(5.1.5+)：默认为所有常见数据库的聚合函数，允许手动添加聚合函数（影响行数），所有以聚合函数开头的函数，在进行 count 转换时，会套一层。其他函数和列会被替换为 count(0)，其中count列可以自己配置。 重要提示：当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 6、如何选择配置这些参数单独看每个参数的说明可能是一件让人不爽的事情，这里列举一些可能会用到某些参数的情况。 场景一如果你仍然在用类似ibatis式的命名空间调用方式，你也许会用到rowBoundsWithCount， 分页插件对RowBounds支持和 MyBatis 默认的方式是一致，默认情况下不会进行 count 查询，如果你想在分页查询时进行 count 查询， 以及使用更强大的 PageInfo 类，你需要设置该参数为 true。 注： PageRowBounds 想要查询总数也需要配置该属性为 true。 场景二如果你仍然在用类似ibatis式的命名空间调用方式，你觉得 RowBounds 中的两个参数 offset,limit 不如 pageNum,pageSize 容易理解， 你可以使用 offsetAsPageNum 参数，将该参数设置为 true 后，offset会当成 pageNum 使用，limit 和 pageSize 含义相同。 场景三如果觉得某个地方使用分页后，你仍然想通过控制参数查询全部的结果，你可以配置 pageSizeZero 为 true， 配置后，当 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果。 场景四如果你分页插件使用于类似分页查看列表式的数据，如新闻列表，软件列表， 你希望用户输入的页数不在合法范围（第一页到最后一页之外）时能够正确的响应到正确的结果页面， 那么你可以配置 reasonable 为 true，这时如果 pageNum&lt;=0 会查询第一页，如果 pageNum&gt;总页数 会查询最后一页。 场景五如果你在 Spring 中配置了动态数据源，并且连接不同类型的数据库，这时你可以配置 autoRuntimeDialect 为 true，这样在使用不同数据源时，会使用匹配的分页进行查询。 这种情况下，你还需要特别注意 closeConn 参数，由于获取数据源类型会获取一个数据库连接，所以需要通过这个参数来控制获取连接后，是否关闭该连接。 默认为 true，有些数据库连接关闭后就没法进行后续的数据库操作。而有些数据库连接不关闭就会很快由于连接数用完而导致数据库无响应。所以在使用该功能时，特别需要注意你使用的数据源是否需要关闭数据库连接。 当不使用动态数据源而只是自动获取 helperDialect 时，数据库连接只会获取一次，所以不需要担心占用的这一个连接是否会导致数据库出错，但是最好也根据数据源的特性选择是否关闭连接。 三、如何在代码中使用重要提示PageHelper.startPage方法重要提示只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。 请不要配置多个分页插件请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring配置方式，请选择其中一种，不要同时配置多个分页插件)！ 分页插件不支持带有for update语句的分页对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。 分页插件不支持嵌套结果映射由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。 分页插件支持以下几种调用方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//第一种，RowBounds方式的调用List&lt;Country&gt; list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(0, 10));//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第四种，参数方法调用//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize( @Param("user") User user, @Param("pageNum") int pageNum, @Param("pageSize") int pageSize);&#125;//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);//第五种，参数对象//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页//有如下 User 对象public class User &#123; //其他fields //下面两个参数名和 params 配置的名字一致 private Integer pageNum; private Integer pageSize;&#125;//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize(User user);&#125;//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); 1、下面对最常用的方式进行详细介绍1List&lt;Country&gt; list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(1, 10)); 使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的 场景一 和 场景二 注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如： 12//这种情况下也会进行物理分页查询List&lt;Country&gt; selectAll(RowBounds rowBounds); 注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的 PageRowBounds，这个对象中增加了 total 属性，执行分页查询后，可以从该属性得到查询总数。 2、PageHelper.startPage 静态方法调用除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 例一： 12345678//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;assertEquals(182, ((Page) list).getTotal()); 例二： 1234567891011121314151617//request: url?pageNum=1&amp;pageSize=10//支持 ServletRequest,Map,POJO 对象，需要配合 params 参数PageHelper.startPage(request);//紧跟着的第一个select方法会被分页List&lt;Country&gt; list = countryMapper.selectIf(1);//后面的不会被分页，除非再次调用PageHelper.startPageList&lt;Country&gt; list2 = countryMapper.selectIf(null);//list1assertEquals(2, list.get(0).getId());assertEquals(10, list.size());//分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;，//或者使用PageInfo类（下面的例子有介绍）assertEquals(182, ((Page) list).getTotal());//list2assertEquals(1, list2.get(0).getId());assertEquals(182, list2.size()); 例三，使用PageInfo的用法： 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); 3、使用参数方式想要使用参数方式，需要配置 supportMethodsArguments 参数为 true，同时要配置 params 参数。 例如下面的配置： 12345678&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name="supportMethodsArguments" value="true"/&gt; &lt;property name="params" value="pageNum=pageNumKey;pageSize=pageSizeKey;"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 在 MyBatis 方法中： 1234List&lt;Country&gt; selectByPageNumSize( @Param("user") User user, @Param("pageNumKey") int pageNum, @Param("pageSizeKey") int pageSize); 当调用这个方法时，由于同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。params 提供的几个参数都可以这样使用。 除了上面这种方式外，如果 User 对象中包含这两个参数值，也可以有下面的方法： 1List&lt;Country&gt; selectByPageNumSize(User user); 当从 User 中同时发现了 pageNumKey 和 pageSizeKey 参数，这个方法就会被分页。 注意：pageNum 和 pageSize 两个属性同时存在才会触发分页操作，在这个前提下，其他的分页参数才会生效。 4、PageHelper 安全调用 使用 RowBounds 和 PageRowBounds 参数方式是极其安全的 使用参数方式是极其安全的 使用 ISelect 接口调用是极其安全的ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 select count(*) 的查询方法。 什么时候会导致不安全的分页？PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。 如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 但是如果你写出下面这样的代码，就是不安全的用法： 1234567PageHelper.startPage(1, 10);List&lt;Country&gt; list;if(param1 != null)&#123; list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子： 1234567List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); list = countryMapper.selectIf(param1);&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这种写法就能保证安全。 如果你对此不放心，你可以手动清理 ThreadLocal 存储的分页参数，可以像下面这样使用： 1234567891011List&lt;Country&gt; list;if(param1 != null)&#123; PageHelper.startPage(1, 10); try&#123; list = countryMapper.selectAll(); &#125; finally &#123; PageHelper.clearPage(); &#125;&#125; else &#123; list = new ArrayList&lt;Country&gt;();&#125; 这么写很不好看，而且没有必要。欢迎访问我的新博客： http://www/xyj123.xyz]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msyql5.6转mysql8遇到的坑]]></title>
    <url>%2Fmysql5.6%E8%BD%ACmysql8%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[我是用在java Web的项目上面的，所以用的是mysql-connect-java-8.0.11版本的jar包。（8.0.12貌似有点问题？） 连接类的与之前有点不同，不然会报找不到类的错误，如下是正确写法： 1Class.forName("com.mysql.cj.jdbc.Driver"); 然后getconnection的参数也多了一点，首先会报如下错误： 12Caused by: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法是在数据库名后面加上serverTimezone=UTC ，如下:1("jdbc:mysql://127.0.0.1/cart?serverTimezone=UTC&amp;characterEncoding=utf-8", "root", "root"); 然后如果mysql报了如下警告： 1Establishing SSL connection without server's identity verification is not recommended 说明数据库建立了连接，只是不太安全。我们需要在后面加上一小段代码,最后正确连接如下： 1("jdbc:mysql://127.0.0.1/cart?serverTimezone=UTC&amp;characterEncoding=utf-8&amp;useSSL=false", "root", "root")]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo可视化编辑问题的解决]]></title>
    <url>%2Fhexo%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91.html</url>
    <content type="text"><![CDATA[最近一时兴起便用hexo+github搭了一个自己的专属博客，地址： http://www.xyj123.xyz界面确实比CSDN好看太多了，但是编辑文章却比较麻烦，所以hexo的可视化编辑也是一个问题。 试过几个编辑器，最终还是选择了CSDN附带的Markdown编辑器哈哈哈，这样既可以在hexo上发布文章，在CSDN上也可以继续更新文章。 只需要在CSDN上编辑好后，copy到sublime或者nodepad++上，加个front-matter就可以了。毕竟用惯了CSDN的编辑器，还是挺好用的。带的功能也挺多的。 图片上传在这根本不是问题，直接粘贴就可以了，不需要安装任何插件，代码处理的也挺好。（吐槽一下好多Markdown编辑器的图片上传非要上传地址的，搞的有的复制粘贴的图根本没法用，在这里csdn直接帮你解决了哈哈哈）]]></content>
      <categories>
        <category>积累经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过cmd查找端口对应程序解决端口冲突]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[在用很多程序，比如nginx，Tomcat，mysql等，经常因为端口被占用而无法运行，所以在这个时候就必须把占用端口的程序给杀死，才能运行当前的程序。（其实好早之前就想记录一下了，只是太懒了）以下所以命令均在cmd命令行进行 1、查看所有进程的端口：1netstat –ano 2、查看某个端口的进程1netstat -ano|findstr [指定端口号] 比如我查找3306端口的进程（也就是mysql），可以看到对应的pid是8512 12netstat -ano|findstr 3306TCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 8512 3、杀死某个端口的进程通过以上命令查到对应程序的端口号后，可以打开任务管理器，转到详细信息那一项，匹配与以上pid对应的程序，并右键结束该任务。如图：当然也可以用命令来杀死程序，但我觉得任务管理器更加方便，这里就不赘述相关命令了。]]></content>
      <categories>
        <category>积累经验</category>
      </categories>
      <tags>
        <tag>端口冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建属于自己的博客]]></title>
    <url>%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[一、本地博客搭建1、node.js的下载与安装这里选择windows安装包的方式安装，32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi选择 v8.12.0 版本，然后进行傻瓜式安装，具体步骤这里不赘述。 安装完成后，检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果：12345PATH=C:\oraclexe\app\oracle\product\8.12.0\server\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;C:\Users\rg\AppData\Roaming\npm 我们可以看到环境变量中已经包含了C:\Program Files\nodejs检查node.js版本:输入node –version 显示对应的版本说明安装成功。 2、git的下载和安装在 Windows 上安装 Git 非常简单，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：项目地址：https://gitforwindows.org/ 直接下载安装即可 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。给 Windows 用户的敬告：你应该在 msysGit 提供的 Unix 风格的 shell 来运行 Git。在 Unix 风格的 shell 中，可以使用本书中提及的复杂多行的命令。对于那些需要在 Windows 命令行中使用 Git 的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来（在 Linux 中是单引号）；另外，如果扬抑符（^）作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。因为扬抑符在 Windows 命令行中表示续行（译注：即下一行为这一行命令的继续）。 至此，基本环境和工具已经搭好了，下载开始搭建博客。 3、hexo的安装与配置在命令行（即Git Bash）运行以下命令：npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可：123hexo init hexo(hexo就是你的站点根目录，名字可以自己改)cd hexonpm install hexo的npm的所有相关命令都在这个站点目录下进行，用git bash命令 站点配置文件：站点目录下的_config.yml，路径为hexo_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。路径为hexo\themes\&lt;主题文件夹&gt;_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：hexo server浏览器访问网址： http://localhost:4000/至此，你的本地博客已经搭建完毕。是不是有点小激动，更激动的在后面呢哈哈。 二、部署到github上。首先去www.github.com 注册一个github的账号。然后创建一个仓库，仓库名为: github账号名.github.io 重点来了，将本地博客推到github仓库。 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：npm install hexo-deployer-git --save 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：ssh -T git@github.comyes 3.修改_config.yml（在站点目录下）。文件末尾修改为：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。在冒号后面一定要加空格，不然会报错的。 4.推送到GithubPages。在命令行（即Git Bash）输入以下命令， 返回INFO Deploy done: git即成功推送：hexo d -g 等待1分钟左右，浏览器访问网址： https://Github账号名称.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://Github账号名称.github.io 三、将刚刚的github域名绑定到自己注册的域名。更加个性化。1、域名解析：类型选择为 CNAME；主机记录即域名前缀，填写为www；记录值填写为 Github账号名称.github.io ；解析线路，TTL 默认即可。 2、仓库设置： 打开博客仓库设置：https://github.com/Github账号名称/Github账号名称.github.io/settings 在Custom domain下，填写自定义域名，点击save。 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online）， 保存，并重命名为CNAME（很重要，不能有后缀）。 3、等待10分钟左右。浏览器访问自定义域名。至此，您的Hexo博客已经解析到自定义域名，https://Github账号名称.github.io 依然可用。 好了，到这已经博客已经基本搭建好了，另外主题更换，优化之类的，可自行百度，后期我可能也会继续更新。有兴趣的还可以把博客搭在coding上。速度会更快点。如果喜欢我的博客，可以直接用我的配置好的主题哦，附上项目地址：https://github.com/jie12366/jie12366.github.io]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+mybatis最新版注解配置实现CURD]]></title>
    <url>%2Fspringboot%2Bmybatis%E6%9C%80%E6%96%B0%E7%89%88%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0CURD.html</url>
    <content type="text"><![CDATA[最近开始学后端，然后直接上手了springboot+mybatis。然后就实现了一个小例子，花了我整整一天时间。在这做个小记录，也给在用最新版的同学一个参考。springboot整合mybatis时，我用的是mybatis3.x最新版的注解方式配置的，这样实现的接口看起来更简单点（确实简单点）。建项目啥的我在这就不说了，直接上主要配置吧。 1、applicaltion.properties的配置：1234567spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456mybatis.type-aliases-package=com.xiangzhang.entity (表的实体类所在的包）# 驼峰命名规范 如：数据库字段是 order_id 那么 实体字段就要写成 orderIdmybatis.configuration.map-underscore-to-camel-case=true 2、pom.xml的依赖：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MYSQL包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入第三方数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试包,当我们使用 mvn package 的时候该包并不会被打入,因为它的生命周期只在 test 之内--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、实体类User123456789101112131415package com.xiangzhang.entity;import lombok.Data;import java.io.Serializable;@Datapublic class User implements Serializable &#123; private static final long serialVersionUID = 8655851615465363473L; private int id; private String name; private float hp; private float damage;&#125; 在这里用了Lombok的@Data注解功能，可以省去getter和setter的代码，可以减少不少的代码量，加快开发速度。lombok需要另外引入依赖。lombok需要另外引入依赖。还要加载对应的lombok plugin插件。不然没法使用哦。 4、UserMapper：通过注解方式实现的接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xiangzhang.mapper;import com.xiangzhang.entity.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * 通过注解方式完成接口的实现 */@Mapperpublic interface UserMapper &#123; /**根据英雄id查询英雄属性 * @param 传入的id * @return 查询的结果集 */ @Select("select * from hero where id = #&#123;id&#125;") List&lt;User&gt; returnById(@Param("id") int id); /** * 返回hero表中的所有数据 * @return 所有结果集 */ @Select("select * from hero") List&lt;User&gt; returnResult(); /** * 实现数据插入功能 * @param name 英雄名 * @param hp 英雄血量值 * @param damage 英雄伤害值 * @return 插入是否成功 */ @Insert("insert into hero(name, hp, damage) VALUES(#&#123;name&#125;, #&#123;hp&#125;, #&#123;damage&#125;)") int insert(@Param("name") String name,@Param("hp") float hp,@Param("damage") float damage); /** *根据英雄id更新英雄名 * @param name 英雄名 * @param id 英雄id * @return 更新是否成功 */ @Update("update hero set name = #&#123;name&#125; where id = #&#123;id&#125;") int update(@Param("name") String name,@Param("id") int id); /** * 根据英雄id删除该英雄 * @param id 英雄id * @return 删除是否成功 */ @Delete("delete from hero where id = #&#123;id&#125;") int delete(@Param("id") int id);&#125; 5、最后再来个测试类代码，结果用log方式输出，在控制台可以观察：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xiangzhang;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import com.xiangzhang.entity.User;import com.xiangzhang.mapper.UserMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; private static final Logger log = LoggerFactory.getLogger(DemoApplicationTests.class); @Autowired private UserMapper userMapper; @Test public void test_curd() throws Exception&#123; final int row1 = userMapper.insert("露娜",2500,4500); if(row1 == 1)&#123; log.info("[添加第一个结果] - [&#123;&#125;]","成功"); &#125; final int row2 = userMapper.insert("貂蝉",1200,5600); if(row2 == 1)&#123; log.info("[添加第二个结果] - [&#123;&#125;]","成功"); &#125; final List&lt;User&gt; user = userMapper.returnById(2); log.info("根据用户id查询 - [&#123;&#125;]",user); final int row3 = userMapper.update("狄仁杰",1); if(row3 == 1)&#123; log.info("[更新英雄名] - [&#123;&#125;]","成功"); &#125; final int row4 = userMapper.delete(11); if(row4 == 1)&#123; log.info("[删除英雄] - [&#123;&#125;]","成功"); &#125; final List&lt;User&gt; users = userMapper.returnResult(); log.info("查询hero表的所有数据 - [&#123;&#125;]",users); &#125;&#125; 如果对你有所帮助，记得点个赞哦。]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3+bootstrap3实现响应式布局]]></title>
    <url>%2Fvue-cli3%20%2B%20bootstrap3%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[利用vue-cli3搭建的脚手架，搭配bootstrap3实现移动端和PC端的适配。 1、用px2rem配合lib-flexible让网页适配。lib-flexible作用：让网页根据设备dpr和宽度，利用viewport和html根元素的font-size配合rem来适配不同尺寸的移动端设备安装： 1npm install lib-flexible 引入：入口文件main.js中： 1import "lib-flexible/flexible.js" 2、手写一个js小工具，省略rem的计算，加快开发速度。在src目录下增加一个utils目录，在里面新建一个js文件，写入以下内容： 123456789101112131415// 基准大小const baseSize = 32// 设置 rem 函数function setRem () &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 750 // 设置页面根节点字体大小 document.documentElement.style.fontSize = (baseSize * Math.min(scale, 2)) + 'px'&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function () &#123; setRem()&#125; 在main.js中引入改js文件： 1import "./utils/rem" 然后就可以直接用px写页面啦，而不用去计算rem的值，是不是很舒服呢。 3、使用VW。了解下vw 与 vh单位，以viewport为基准，1vw 与 1vh分别为window.innerWidth 与 window.innerHeight的百分之一安装： 1npm i postcss-px-to-viewport -save -dev 在package.json中配置如下： 12345678910111213141516"postcss": &#123; "plugins": &#123; "autoprefixer": &#123;&#125;, "postcss-pxtorem": &#123; "rootValue": 32, "propList": ["*"] &#125; &#125;, "plugins": &#123; "autoprefixer": &#123;&#125;, "postcss-px-to-viewport": &#123; "viewportWidth": 750, "minPixelValue": 1 &#125; &#125; &#125;, 4、利用bootstrap实现响应式图片在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。对于图片的大小限制一定要在图片的父级元素进行限制。 5、利用bootstrap的栅格系统，下面列一下栅格系统的参数： 超小屏手机 (&lt;768px) 小屏幕平板(&gt;=768px) 中等屏桌面(&gt;=992px) 大屏桌面(&gt;=1200px) 类前缀 .col-xs .col-sm .col-md .col-lg 列数 12 12 12 12 .container最大宽度 None(自动) 750px 970px 1170px 举个移动设备和桌面的例子：123456789101112131415161718&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-12 col-md-8"&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns are always 50% wide, on mobile and desktop --&gt;&lt;div class="row"&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; 还有更多对响应式的支持，就不一一列举了。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
