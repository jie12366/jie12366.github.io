[{"title":"hexo+github搭建属于自己的博客","date":"2019-03-03T06:56:31.574Z","path":"hexo+github搭建博客.html","text":"一、本地博客搭建1、node.js的下载与安装这里选择windows安装包的方式安装，32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi选择 v8.12.0 版本，然后进行傻瓜式安装，具体步骤这里不赘述。 安装完成后，检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果：12345PATH=C:\\oraclexe\\app\\oracle\\product\\8.12.0\\server\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;c:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs检查node.js版本:输入node –version 显示对应的版本说明安装成功。 2、git的下载和安装在 Windows 上安装 Git 非常简单，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：项目地址：https://gitforwindows.org/ 直接下载安装即可 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。给 Windows 用户的敬告：你应该在 msysGit 提供的 Unix 风格的 shell 来运行 Git。在 Unix 风格的 shell 中，可以使用本书中提及的复杂多行的命令。对于那些需要在 Windows 命令行中使用 Git 的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来（在 Linux 中是单引号）；另外，如果扬抑符（^）作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。因为扬抑符在 Windows 命令行中表示续行（译注：即下一行为这一行命令的继续）。 至此，基本环境和工具已经搭好了，下载开始搭建博客。 3、hexo的安装与配置在命令行（即Git Bash）运行以下命令：npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可：123hexo init hexo(hexo就是你的站点根目录，名字可以自己改)cd hexonpm install hexo的npm的所有相关命令都在这个站点目录下进行，用git bash命令 站点配置文件：站点目录下的_config.yml，路径为hexo_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。路径为hexo\\themes\\&lt;主题文件夹&gt;_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：hexo server浏览器访问网址： http://localhost:4000/至此，你的本地博客已经搭建完毕。是不是有点小激动，更激动的在后面呢哈哈。 二、部署到github上。首先去www.github.com 注册一个github的账号。然后创建一个仓库，仓库名为: github账号名.github.io 重点来了，将本地博客推到github仓库。 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：npm install hexo-deployer-git --save 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：ssh -T git@github.comyes 3.修改_config.yml（在站点目录下）。文件末尾修改为：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。在冒号后面一定要加空格，不然会报错的。 4.推送到GithubPages。在命令行（即Git Bash）输入以下命令， 返回INFO Deploy done: git即成功推送：hexo d -g 等待1分钟左右，浏览器访问网址： https://Github账号名称.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://Github账号名称.github.io 三、将刚刚的github域名绑定到自己注册的域名。更加个性化。1、域名解析：类型选择为 CNAME；主机记录即域名前缀，填写为www；记录值填写为 Github账号名称.github.io ；解析线路，TTL 默认即可。 2、仓库设置： 打开博客仓库设置：https://github.com/Github账号名称/Github账号名称.github.io/settings 在Custom domain下，填写自定义域名，点击save。 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online）， 保存，并重命名为CNAME（很重要，不能有后缀）。 3、等待10分钟左右。浏览器访问自定义域名。至此，您的Hexo博客已经解析到自定义域名，https://Github账号名称.github.io 依然可用。 好了，到这已经博客已经基本搭建好了，另外主题更换，优化之类的，可自行百度，后期我可能也会继续更新。有兴趣的还可以把博客搭在coding上。速度会更快点","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.xyj123.xyz/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.xyj123.xyz/tags/github/"}]},{"title":"springboot+mybatis最新版注解配置实现CURD","date":"2019-03-03T03:34:49.060Z","path":"springboot+mybatis最新版注解配置实现CURD.html","text":"最近开始学后端，然后直接上手了springboot+mybatis。然后就实现了一个小例子，花了我整整一天时间。在这做个小记录，也给在用最新版的同学一个参考。springboot整合mybatis时，我用的是mybatis3.x最新版的注解方式配置的，这样实现的接口看起来更简单点（确实简单点）。建项目啥的我在这就不说了，直接上主要配置吧。 1、applicaltion.properties的配置：1234567spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456mybatis.type-aliases-package=com.xiangzhang.entity (表的实体类所在的包）# 驼峰命名规范 如：数据库字段是 order_id 那么 实体字段就要写成 orderIdmybatis.configuration.map-underscore-to-camel-case=true 2、pom.xml的依赖：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MYSQL包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入第三方数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试包,当我们使用 mvn package 的时候该包并不会被打入,因为它的生命周期只在 test 之内--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、实体类User123456789101112131415package com.xiangzhang.entity;import lombok.Data;import java.io.Serializable;@Datapublic class User implements Serializable &#123; private static final long serialVersionUID = 8655851615465363473L; private int id; private String name; private float hp; private float damage;&#125; 在这里用了Lombok的@Data注解功能，可以省去getter和setter的代码，可以减少不少的代码量，加快开发速度。lombok需要另外引入依赖。 4、UserMapper：通过注解方式实现的接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xiangzhang.mapper;import com.xiangzhang.entity.User;import org.apache.ibatis.annotations.*;import java.util.List;/** * 通过注解方式完成接口的实现 */@Mapperpublic interface UserMapper &#123; /**根据英雄id查询英雄属性 * @param 传入的id * @return 查询的结果集 */ @Select(\"select * from hero where id = #&#123;id&#125;\") List&lt;User&gt; returnById(@Param(\"id\") int id); /** * 返回hero表中的所有数据 * @return 所有结果集 */ @Select(\"select * from hero\") List&lt;User&gt; returnResult(); /** * 实现数据插入功能 * @param name 英雄名 * @param hp 英雄血量值 * @param damage 英雄伤害值 * @return 插入是否成功 */ @Insert(\"insert into hero(name, hp, damage) VALUES(#&#123;name&#125;, #&#123;hp&#125;, #&#123;damage&#125;)\") int insert(@Param(\"name\") String name,@Param(\"hp\") float hp,@Param(\"damage\") float damage); /** *根据英雄id更新英雄名 * @param name 英雄名 * @param id 英雄id * @return 更新是否成功 */ @Update(\"update hero set name = #&#123;name&#125; where id = #&#123;id&#125;\") int update(@Param(\"name\") String name,@Param(\"id\") int id); /** * 根据英雄id删除该英雄 * @param id 英雄id * @return 删除是否成功 */ @Delete(\"delete from hero where id = #&#123;id&#125;\") int delete(@Param(\"id\") int id);&#125; 5、最后再来个测试类代码，结果用log方式输出，在控制台可以观察：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xiangzhang;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import com.xiangzhang.entity.User;import com.xiangzhang.mapper.UserMapper;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; private static final Logger log = LoggerFactory.getLogger(DemoApplicationTests.class); @Autowired private UserMapper userMapper; @Test public void test_curd() throws Exception&#123; final int row1 = userMapper.insert(\"露娜\",2500,4500); if(row1 == 1)&#123; log.info(\"[添加第一个结果] - [&#123;&#125;]\",\"成功\"); &#125; final int row2 = userMapper.insert(\"貂蝉\",1200,5600); if(row2 == 1)&#123; log.info(\"[添加第二个结果] - [&#123;&#125;]\",\"成功\"); &#125; final List&lt;User&gt; user = userMapper.returnById(2); log.info(\"根据用户id查询 - [&#123;&#125;]\",user); final int row3 = userMapper.update(\"狄仁杰\",1); if(row3 == 1)&#123; log.info(\"[更新英雄名] - [&#123;&#125;]\",\"成功\"); &#125; final int row4 = userMapper.delete(11); if(row4 == 1)&#123; log.info(\"[删除英雄] - [&#123;&#125;]\",\"成功\"); &#125; final List&lt;User&gt; users = userMapper.returnResult(); log.info(\"查询hero表的所有数据 - [&#123;&#125;]\",users); &#125;&#125; 如果对你有所帮助，记得点个赞哦。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.xyj123.xyz/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.xyj123.xyz/tags/mybatis/"}]},{"title":"vue-cli3+bootstrap3实现响应式布局","date":"2019-03-03T02:23:27.505Z","path":"vue-cli3 + bootstrap3实现响应式布局.html","text":"利用vue-cli3搭建的脚手架，搭配bootstrap3实现移动端和PC端的适配。 1、用px2rem配合lib-flexible，省略rem的计算，大大加快开发速度。lib-flexible作用：让网页根据设备dpr和宽度，利用viewport和html根元素的font-size配合rem来适配不同尺寸的移动端设备安装： 1npm install lib-flexible 引入：入口文件main.js中： 1import \"lib-flexible/flexible.js\" 2、使用VW。了解下vw 与 vh单位，以viewport为基准，1vw 与 1vh分别为window.innerWidth 与 window.innerHeight的百分之一安装： 1npm i postcss-px-to-viewport -save -dev 在package.json中配置如下： 12345678910111213141516\"postcss\": &#123; \"plugins\": &#123; \"autoprefixer\": &#123;&#125;, \"postcss-pxtorem\": &#123; \"rootValue\": 32, \"propList\": [\"*\"] &#125; &#125;, \"plugins\": &#123; \"autoprefixer\": &#123;&#125;, \"postcss-px-to-viewport\": &#123; \"viewportWidth\": 750, \"minPixelValue\": 1 &#125; &#125; &#125;, 3、利用bootstrap实现响应式图片在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。对于图片的大小限制一定要在图片的父级元素进行限制。 4、利用bootstrap的栅格系统，下面列一下栅格系统的参数： 超小屏手机 (&lt;768px) 小屏幕平板(&gt;=768px) 中等屏桌面(&gt;=992px) 大屏桌面(&gt;=1200px) 类前缀 .col-xs .col-sm .col-md .col-lg 列数 12 12 12 12 .container最大宽度 None(自动) 750px 970px 1170px 举个移动设备和桌面的例子：123456789101112131415161718&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12 col-md-8\"&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class=\"col-xs-6 col-md-4\"&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;&lt;!-- Columns are always 50% wide, on mobile and desktop --&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6\"&gt;.col-xs-6&lt;/div&gt; &lt;div class=\"col-xs-6\"&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; 还有更多对响应式的支持，就不一一列举了。","tags":[{"name":"响应式布局","slug":"响应式布局","permalink":"http://www.xyj123.xyz/tags/响应式布局/"}]},{"title":"Hello World","date":"2019-03-02T03:25:29.536Z","path":"hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]